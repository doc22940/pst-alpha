// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !! THIS FILE IS AUTOMATICALLY GENERATED. EDITS WILL BE CLOBBERED !!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#pragma once

const char *shader_source_common_uniforms = R"GLSL(layout(std140) uniform CommonUniforms {
  mat4 iModelViewProjection;
  mat4 iModelView;
  mat4 iProjection;
  mat4 iInverseModelViewProjection;
  mat4 iInverseModelView;
  mat4 iInverseProjection;

  mat4 iControllerTransform[2]; // [Left, Right]
  vec4 iControllerVelocity[2];
  vec4 iControllerButtons[2];

  float iTime;
  float iTimeDelta;
  int iFrame;
};

uniform sampler2D iFragData[6];
uniform ivec2 iResolution;
)GLSL";

const char *shader_source_shade_fs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

// {{fragment}}

in vec4 vColor;
in vec2 vTexcoord;

out vec4 oFragColor;

void main() {
  mainFragment(oFragColor, vColor, vTexcoord);
}
)GLSL";

const char *shader_source_shade_vs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

// {{vertex}}

layout(location = 0) in vec2 aQuadPosition;
layout(location = 1) in vec2 aQuadTexcoord;
layout(location = 2) in ivec2 aParticleCoord;

out vec4 vColor;
out vec2 vTexcoord;

void main() {
  vTexcoord = aQuadTexcoord;
  mainVertex(gl_Position, vColor, aQuadPosition, aParticleCoord);
}
)GLSL";

const char *shader_source_simulation_fs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

// {{simulation}}

layout(location = 0) out vec4 oFragData0;
layout(location = 1) out vec4 oFragData1;
layout(location = 2) out vec4 oFragData2;
layout(location = 3) out vec4 oFragData3;
layout(location = 4) out vec4 oFragData4;
layout(location = 5) out vec4 oFragData5;

void main() {
  mainSimulation(oFragData0, oFragData1, oFragData2, oFragData3, oFragData4, oFragData5);
}
)GLSL";

const char *shader_source_simulation_vs = R"GLSL(#version 300 es

precision highp float;
precision highp int;

layout(location = 0) in vec4 aPosition;

void main() {
  gl_Position = aPosition;
}
)GLSL";

const char *shader_source_user_default_common = R"GLSL(// The contents of this tab will be prefixed in all shaders.
)GLSL";

const char *shader_source_user_default_fragment = R"GLSL(// https://developer.oculus.com/blog/tech-note-shader-snippets-for-efficient-2d-dithering/
float dither17(vec2 p) {
	vec3 k0 = vec3(2.0, 7.0, 23.0);
	float ret = dot(vec3(p, float(iFrame & 34)), k0 / 17.0);
	return fract(ret);
}

vec2 rotate(vec2 v, float t) {
  return vec2(v.x * cos(t) - v.y * sin(t), v.x * sin(t) + v.y * cos(t));
}

in float vDepth;

void mainFragment(out vec4 oColor, in vec4 color, in vec2 texcoord) {
  vec2 p = texcoord - vec2(0.5);
  float d = length(p);
  p = rotate(p, d * (color.a * 20.0 + 5.0) - iTime * 2.0);
  p.x *= 2.0;
  d = length(p);
  float alpha = smoothstep(0.5, 0.25, d);

  if (alpha < dither17(gl_FragCoord.xy)) discard;
  
  float b = smoothstep(0.8, 0.0, d);
  b = b * b * b * 1.5;
  oColor = vec4(color.rgb * b * (0.25 / vDepth), 1.0);
}
)GLSL";

const char *shader_source_user_default_simulation = R"GLSL(vec3 hash3(uint n) {
  n = (n << 13U) ^ n;
  n = n * (n * n * 15731U + 789221U) + 1376312589U;
  uvec3 k = n * uvec3(n, n * 16807U, n * 48271U);
  return vec3(k & uvec3(0x7fffffffU)) / float(0x7fffffff);
}

void mainSimulation(out vec4 oPosition, out vec4 oColor, out vec4 oRight, out vec4 oUp, out vec4 oPrevPos, out vec4 oExtra) {
  ivec2 texcoord = ivec2(gl_FragCoord);
  int id = (texcoord.x + texcoord.y * iResolution.x);

  if (iFrame == 0 || iControllerButtons[1][2] > 0.0) {
    vec3 r0 = hash3(uint(id));
    vec3 r1 = hash3(uint(id + 1));
    vec3 r2 = hash3(uint(id + 2));
    
    oPosition = vec4(r0 * 0.25 - 0.125, 1.0);
    oPosition.z -= 1.0;
    oPrevPos = oPosition;
    oPrevPos.xyz -= (r2 - 0.5) * 0.01;
    oRight = vec4(normalize(r1), 1.0);
    oUp = vec4(normalize(cross(oRight.xyz, r2)), 1.0);
    float scale = 0.18 + r1.x * 0.15;
    scale *= scale * scale;
    oRight *= scale;
    oUp *= scale;
    oColor.xyz = r0;
    oExtra = vec4(r1, 0.0);
  }
  else {
    vec4 pos = texelFetch(iFragData[0], texcoord, 0);
    vec4 ppos = texelFetch(iFragData[4], texcoord, 0);

    vec4 vel = pos - ppos;
    vel *= 0.995;

    oExtra = texelFetch(iFragData[5], texcoord, 0);

    for (int i = 0; i < 2; ++i) {
      float b1 = iControllerButtons[i][1];
      if (b1 > 0.0) {
        vec4 o = iControllerTransform[i][3] - pos;
        vel += o / length(o) * 0.001 * b1 * b1 * b1;
      }
    }

    oPosition = pos + vel;
    oPrevPos = pos;

    oColor = texelFetch(iFragData[1], texcoord, 0);
    oRight = texelFetch(iFragData[2], texcoord, 0);
    oUp = texelFetch(iFragData[3], texcoord, 0);
  }
}
)GLSL";

const char *shader_source_user_default_vertex = R"GLSL(out float vDepth;

void mainVertex(out vec4 oPosition, out vec4 oColor, in vec2 quadPosition, in ivec2 particleCoord) {
  vec4 particlePos = texelFetch(iFragData[0], particleCoord, 0);
  particlePos.xyz += texelFetch(iFragData[2], particleCoord, 0).xyz * quadPosition.x;
  particlePos.xyz += texelFetch(iFragData[3], particleCoord, 0).xyz * quadPosition.y;

  oPosition = iModelViewProjection * particlePos;
  vDepth = oPosition.z;

  oColor.rgb = texelFetch(iFragData[1], particleCoord, 0).rgb;
  oColor.a = texelFetch(iFragData[5], particleCoord, 0).r;
}
)GLSL";
