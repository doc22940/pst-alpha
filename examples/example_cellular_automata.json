{"camera":{"position":[0,0,0],"orientation":[0,0,0,1]},"shaders":[{"source":"const ivec3 dirs[26] = ivec3[26](\n  // Von-Neumann Faces\n  ivec3( 0,  0, -1),\n  ivec3( 0, -1,  0),\n  ivec3(-1,  0,  0),\n  ivec3( 0,  1,  0),\n  ivec3( 1,  0,  0),\n  ivec3( 0,  0,  1),\n\n  // Moore Edges\n  ivec3(-1,  0, -1),\n  ivec3( 1,  0, -1),\n  ivec3( 0, -1, -1),\n  ivec3( 0,  1, -1),\n  \n  ivec3(-1, -1, 0),\n  ivec3( 1, -1, 0),\n  ivec3(-1,  1, 0),\n  ivec3( 1,  1, 0),\n\n  ivec3(-1,  0, 1),\n  ivec3( 1,  0, 1),\n  ivec3( 0, -1, 1),\n  ivec3( 0,  1, 1),\n\n  // Moore Corners\n  ivec3(-1, -1, -1),\n  ivec3( 1, -1, -1),\n  ivec3(-1,  1, -1),\n  ivec3( 1,  1, -1),\n  ivec3(-1, -1,  1),\n  ivec3( 1, -1,  1),\n  ivec3(-1,  1,  1),\n  ivec3( 1,  1,  1)\n);\n\nfloat hash1(uint n) {\n  n = (n << 13U) ^ n;\n  n = n * (n * n * 15731U + 789221U) + 1376312589U;\n  return float(n & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nconst int DIM = 64;\nconst int DIM1 = DIM - 1;\nconst int DIMDIM = DIM * DIM;\nconst int HDIM = DIM / 2;\n\nvec4 getVoxel(in ivec3 c) {\n  if (any(lessThan(c, ivec3(0.0))) || any(greaterThanEqual(c, ivec3(DIM)))) {\n    return vec4(0.0);\n  }\n  int i = c.x + c.y * DIM + c.z * DIMDIM;\n  return texelFetch(iFragData[1], ivec2(i % iSize.x, i / iSize.x), 0);\n}\n\nvec4 getVoxelWrap(in ivec3 c) {\n  c = (c + DIM) % DIM; // Wrap\n  int i = c.x + c.y * DIM + c.z * DIMDIM;\n  return texelFetch(iFragData[1], ivec2(i % iSize.x, i / iSize.x), 0);\n}\n"},{"source":"/*\n\n3D Cellular Automata\n\nRyan Alexander 2020\nhttps://onecm.com\n\n*/\n\n#pragma size 512 512\n\n#define CA_RULE_S (count == 4)\n#define CA_RULE_B (count == 4)\n#define CA_RULE_C 5\n\n// Builder\n// #define CA_RULE_S (count == 2 || count == 6 || count == 9)\n// #define CA_RULE_B (count == 4 || count == 6 || count == 8 || count == 9)\n// #define CA_RULE_C 10\n\n// Pyroclastic\n// #define CA_RULE_S (count >= 4 && count <= 7)\n// #define CA_RULE_B (count >= 6 && count <= 8)\n// #define CA_RULE_C 10\n\nvoid mainSimulation(out vec4 oPosition, out vec4 oState, out vec4 oColor, out vec4 oCoord, out vec4 oData4, out vec4 oData5) {\n  ivec2 fragCoord = ivec2(gl_FragCoord);\n  int id = fragCoord.x + fragCoord.y * iSize.x;\n\n  ivec3 coord = ivec3(id % DIM, (id % DIMDIM) / DIM, id / DIMDIM);\n  \n  oCoord = vec4(coord, 1.0);\n  oPosition = vec4(oCoord.xyz / float(DIM), 1.0);\n  oColor = oPosition;\n\n  oPosition.xyz -= 0.5;\n  oPosition.z -= 1.4;\n\n  oState = texelFetch(iFragData[1], fragCoord, 0);\n\n  int count = 0;\n  int faces = 0;\n  int i = 0;\n  for (; i < 6; ++i) {\n    float v = getVoxelWrap(coord + dirs[i]).x;\n    if (v >= 1.0) {\n      faces |= 1 << i;\n      if (v == 1.0) count++;\n    }\n  }\n  faces &= ~(int(coord.z == 0) | int(coord.y == 0) << 1 | int(coord.x == 0) << 2 | int(coord.y == DIM1) << 3 | int(coord.x == DIM1) << 4 | int(coord.z == DIM1) << 5);\n  for (; i < 26; ++i) {\n    if (getVoxelWrap(coord + dirs[i]).x == 1.0) count++;\n  }\n  oState.y = oState.x; // Stash previous state for vertex phase\n  oState.z = float(count);\n  oState.w = float(faces);\n\n  if (iFrame == 0) {\n    int cmin = HDIM - 5;\n    int cmax = HDIM + 5;\n    if (coord.x >= cmin && coord.y >= cmin && coord.z >= cmin && coord.x <= cmax && coord.y <= cmax && coord.z <= cmax) {\n      oState = vec4(round(hash1(uint(id)) + 0.2), 0.0, 0.0, 0.0);\n    }\n    else {\n      oState = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n  }\n  else if (iFrame % 1 == 0) {\n    int gen = int(oState.x);\n    if (gen == 0) {\n      if (CA_RULE_B) gen = 1;\n    }\n    else if (gen == 1 && CA_RULE_S) { // Sustain (S)\n    }\n    else {\n      gen = (gen + 1) % CA_RULE_C;\n    }\n    oState.x = float(gen);\n  }\n\n  oColor.a *= min(1.0, oState.y);\n  oColor.g = oState.y / float(CA_RULE_C - 1);\n}\n"},{"source":"#pragma vertexCount 36\n#pragma cull back\n\n#define AO 1\n\nconst vec3 cubeVertices[8] = vec3[8](\n  vec3(-1.0, -1.0, -1.0),\n  vec3( 1.0, -1.0, -1.0),\n  vec3(-1.0,  1.0, -1.0),\n  vec3( 1.0,  1.0, -1.0),\n  vec3(-1.0, -1.0,  1.0),\n  vec3( 1.0, -1.0,  1.0),\n  vec3(-1.0,  1.0,  1.0),\n  vec3( 1.0,  1.0,  1.0)\n);\n\nconst vec3 cubeNormals[6] = vec3[6](\n  vec3( 0.0,  0.0, -1.0),\n  vec3( 0.0, -1.0,  0.0),\n  vec3(-1.0,  0.0,  0.0),\n  vec3( 0.0,  1.0,  0.0),\n  vec3( 1.0,  0.0,  0.0),\n  vec3( 0.0,  0.0,  1.0)\n);\n\nconst vec2 cubeTexcoords[6] = vec2[6](\n  vec2(0.0, 0.0),\n  vec2(1.0, 1.0),\n  vec2(0.0, 1.0),\n  vec2(0.0, 0.0),\n  vec2(1.0, 0.0),\n  vec2(1.0, 1.0)\n);\n\nconst int cubeIndices[36] = int[36](\n  1, 2, 3,\n  1, 0, 2,\n  0, 5, 4,\n  0, 1, 5,  \n  0, 6, 2,\n  0, 4, 6,\n  6, 3, 2,\n  6, 7, 3,\n  5, 3, 7,\n  5, 1, 3,\n  4, 7, 6,\n  4, 5, 7\n);\n\nout vec4 vColor;\nout vec4 vPosition;\n\nvoid mainVertex(out vec4 oPosition) {\n  int faceID = gl_VertexID / 6 % 6;\n  int instanceID = gl_VertexID / 36;\n  ivec2 fragCoord = ivec2(instanceID % iSize.x, instanceID / iSize.x);\n\n  vColor = texelFetch(iFragData[2], fragCoord, 0);\n\n  int faces = int(texelFetch(iFragData[1], fragCoord, 0).w);\n\n  if (vColor.a == 0.0 || (1 << faceID & faces) > 0) {\n    oPosition = vec4(0.0);\n  }\n  else {\n    oPosition = texelFetch(iFragData[0], fragCoord, 0);\n\n    int vi = gl_VertexID % 36;\n    int ci = cubeIndices[vi];\n    oPosition.xyz += cubeVertices[ci] * (0.5 / float(DIM));\n\n    vPosition = oPosition;\n    oPosition = iModelViewProjection * oPosition;\n\n    vec3 normal = cubeNormals[faceID];\n\n#if AO\n    // Ambient Occlusion\n    ivec3 coord = ivec3(texelFetch(iFragData[3], fragCoord, 0).xyz);\n    bvec3 mask = notEqual(ivec3(0), dirs[faceID]);\n    float ao = 0.0;\n    for (int i = 0; i < 3; ++i) {\n      ivec3 dir = dirs[18 + ci];\n      dir[i] *= int(mask[i]);\n      ao += min(1.0, getVoxel(coord + dir).y);\n    }\n    ao = 1.0 - ao / 4.0;\n#else\n    float ao = 1.0;\n#endif\n\n    // Lighting\n    vec3 lightDir = normalize(vec3(0.6, 1.0, 0.3));\n    vec3 lightColor = vec3(6.0, 6.0, 4.0);\n    vec3 skyColor = vec3(1.2, 1.6, 1.8);\n    vec3 material = vColor.rgb * 0.18;\n    float diffuse = max(0.0, dot(lightDir, normal));\n    vec3 color = vec3(0.0);\n    color += material * lightColor * diffuse;\n    color += material * skyColor * ao;\n    vColor.rgb = color;\n\n    // Curves\n    vColor.rgb = pow(vColor.rgb, vec3(0.7, 1.1, 1.2));\n  }\n}\n"},{"source":"in vec4 vColor;\nin vec4 vPosition;\n\nvoid mainFragment(out vec4 oColor) {\n  oColor = vColor;\n\n  // Fog\n  float d = 0.3 * distance(iInverseModelView[3].xyz, vPosition.xyz);\n  oColor.rgb *= 1.0 / exp(d * d);\n\n  oColor.rgb = pow(oColor.rgb, vec3(0.4545));\n  oColor.rgb = smoothstep(0.01, 1.0, oColor.rgb);\n}\n"}]}